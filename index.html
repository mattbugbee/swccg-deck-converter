<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SWCCG Deck Converter for GEMP</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for webkit browsers */
        textarea::-webkit-scrollbar {
            width: 8px;
        }
        textarea::-webkit-scrollbar-track {
            background: #2d3748; /* gray-800 */
        }
        textarea::-webkit-scrollbar-thumb {
            background: #4a5568; /* gray-600 */
            border-radius: 4px;
        }
        textarea::-webkit-scrollbar-thumb:hover {
            background: #718096; /* gray-500 */
        }
        /* Style for disabled button */
        button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl mx-auto">
        <header class="text-center mb-6">
            <h1 class="text-4xl font-bold text-yellow-400">SWCCG Deck Converter</h1>
            <p class="text-gray-400 mt-2">Convert plain-text decklists to GEMP XML format.</p>
        </header>

        <div class="text-center mb-6">
            <button id="convert-btn" class="bg-yellow-500 text-gray-900 font-bold py-3 px-8 rounded-lg hover:bg-yellow-400 transition-colors shadow-md text-lg" disabled>Convert</button>
            <button id="copy-btn" class="bg-blue-500 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-400 transition-colors shadow-md ml-4 text-lg">Copy output to clipboard</button>
            <p id="status-message" class="text-yellow-300 mt-4 h-6">Loading card database...</p>
            <p id="copy-feedback" class="text-green-400 mt-4 h-6 transition-opacity opacity-0"></p>
            <!-- New Error Display Area -->
            <div id="error-display" class="mt-4 p-4 bg-red-900/50 border border-red-700 rounded-lg text-red-300 hidden"></div>
        </div>

        <main class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <!-- Input Section -->
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                <label for="plain-text-input" class="block text-lg font-semibold mb-2">Paste Decklist Here</label>
                <p class="text-sm text-gray-500 mb-4">Format: `1x Card Name`. Category headers are ignored.</p>
                <textarea id="plain-text-input" rows="20" class="w-full p-3 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-yellow-500 transition-shadow" placeholder="CHARACTER&#10;1x Luke Skywalker, Jedi Knight&#10;1x My Lord, Is That Legal?&#10;&#10;WEAPON&#10;1x Luke's Lightsaber" autocorrect="off" autocapitalize="off" spellcheck="false"></textarea>
            </div>

            <!-- Output Section -->
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                <label for="xml-output" class="block text-lg font-semibold mb-2">GEMP XML Output</label>
                 <p class="text-sm text-gray-500 mb-4">Ready to copy and import into GEMP.</p>
                <textarea id="xml-output" rows="20" readonly class="w-full p-3 bg-gray-900 border border-gray-700 rounded-md cursor-not-allowed"></textarea>
            </div>
        </main>

    </div>

    <script>
        // --- Global Variables ---
        let cardDatabase = {};
        let isDataLoaded = false;

        // --- Element References ---
        const convertBtn = document.getElementById('convert-btn');
        const copyBtn = document.getElementById('copy-btn');
        const plainTextInput = document.getElementById('plain-text-input');
        const xmlOutput = document.getElementById('xml-output');
        const statusMessage = document.getElementById('status-message');
        const copyFeedback = document.getElementById('copy-feedback');
        const errorDisplay = document.getElementById('error-display');

        // --- Core Functions ---

        /**
         * Normalizes a card title by cleaning it, extracting suffixes like (V) or (AI),
         * sorting them, and re-attaching them for consistent matching.
         * @param {string} title The card title to normalize.
         * @returns {string} The normalized card title.
         */
        function normalizeTitle(title) {
            const suffixRegex = /\s*(\([^)]+\))/g;
            let cleanTitle = title.replace(/â€¢/g, '').trim();
            const suffixes = [];
            let match;
            while ((match = suffixRegex.exec(cleanTitle)) !== null) {
                suffixes.push(match[1]);
            }
            const baseTitle = cleanTitle.replace(suffixRegex, '').trim();
            suffixes.sort();
            return `${baseTitle}${suffixes.join('')}`;
        }


        /**
         * Fetches card data from SCOMP JSON files and populates the database.
         */
        async function loadCardData() {
            const lightSideUrl = 'https://raw.githubusercontent.com/swccgpc/swccg-card-json/refs/heads/main/Light.json';
            const darkSideUrl = 'https://raw.githubusercontent.com/swccgpc/swccg-card-json/refs/heads/main/Dark.json';

            try {
                const responses = await Promise.all([fetch(lightSideUrl), fetch(darkSideUrl)]);
                for (const response of responses) {
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                }
                const [lightSideData, darkSideData] = await Promise.all(responses.map(res => res.json()));

                const processCards = (cardList, side) => {
                    for (const card of cardList) {
                        // **FIXED**: Exclude Defensive Shields from the database.
                        if (card.front.type === "Defensive Shield") {
                            continue; // Skip this card and move to the next one
                        }

                        const fullTitle = card.front.title;
                        if (fullTitle && card.gempId) {
                            const titles = fullTitle.split(' / ');
                            for (const title of titles) {
                                const normalized = normalizeTitle(title);
                                if (!cardDatabase[normalized]) {
                                    cardDatabase[normalized] = {};
                                }
                                cardDatabase[normalized][side] = card.gempId;
                            }
                        }
                    }
                };

                processCards(lightSideData.cards, "Light");
                processCards(darkSideData.cards, "Dark");

                isDataLoaded = true;
                statusMessage.textContent = `Database loaded with ${Object.keys(cardDatabase).length} unique titles. Ready!`;
                statusMessage.classList.remove('text-yellow-300');
                statusMessage.classList.add('text-green-400');
                convertBtn.disabled = false;

            } catch (error) {
                console.error("Failed to load card database:", error);
                statusMessage.textContent = 'Error loading card database. Please try refreshing.';
                statusMessage.classList.add('text-red-500');
            }
        }
        
        /**
         * Escapes characters for safe inclusion in XML attributes.
         * @param {string} str The string to escape.
         * @returns {string} The escaped string.
         */
        function escapeXml(str) {
            // Reverted to the correct XML escaping function.
            // This handles required characters like '&' but leaves apostrophes alone.
            return str.replace(/[<>&"]/g, (char) => {
                switch (char) {
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '&': return '&amp;';
                    case '"': return '&quot;';
                    default: return char;
                }
            });
        }

        /**
         * Converts the plain text input to GEMP XML format.
         */
        function convertToXml() {
            if (!isDataLoaded) {
                showFeedback("Card database is not loaded yet. Please wait.", "red");
                return;
            }

            const inputText = plainTextInput.value;
            const lines = inputText.split('\n');
            const lineRegex = /^\s*(\d+)\s*[xX]?\s*(.+?)\s*$/;
            
            // --- First Pass: Determine Deck Allegiance ---
            let lightCount = 0;
            let darkCount = 0;
            lines.forEach(line => {
                const match = line.match(lineRegex);
                if (match) {
                    const title = normalizeTitle(match[2].trim());
                    const cardEntry = cardDatabase[title];
                    if (cardEntry) {
                        const sides = Object.keys(cardEntry);
                        if (sides.length === 1) { // Unambiguous card
                            if (sides[0] === "Light") lightCount++;
                            if (sides[0] === "Dark") darkCount++;
                        }
                    }
                }
            });
            
            const deckSide = lightCount >= darkCount ? "Light" : "Dark";
            
            // --- Second Pass: Generate XML and Collect Errors ---
            const xmlCards = [];
            const notFoundCards = new Set(); // Use a Set to avoid duplicate error messages

            lines.forEach(line => {
                const match = line.match(lineRegex);
                if (match) {
                    const quantity = parseInt(match[1], 10);
                    const originalTitle = match[2].trim();
                    const normalizedTitle = normalizeTitle(originalTitle);
                    const cardEntry = cardDatabase[normalizedTitle];
                    let blueprintId = null;

                    if (cardEntry) {
                        if (cardEntry[deckSide]) {
                            blueprintId = cardEntry[deckSide];
                        } else {
                            const availableSides = Object.keys(cardEntry);
                            blueprintId = cardEntry[availableSides[0]];
                        }
                    }
                    
                    if (blueprintId) {
                        // Use the escapeXml function to create a valid title attribute.
                        const escapedTitle = escapeXml(normalizedTitle);
                        for (let i = 0; i < quantity; i++) {
                            xmlCards.push(`    <card blueprintId="${blueprintId}" title="${escapedTitle}"/>`);
                        }
                    } else {
                        xmlCards.push(`    <!-- Card not found: ${originalTitle} -->`);
                        notFoundCards.add(originalTitle); // Add to error list
                    }
                }
            });

            // --- Display Errors if any ---
            errorDisplay.innerHTML = ''; // Clear previous errors
            errorDisplay.classList.add('hidden');

            if (notFoundCards.size > 0) {
                let errorHtml = '<p class="font-bold mb-2">The following cards were not found:</p><ul class="list-disc list-inside text-left inline-block">';
                notFoundCards.forEach(cardTitle => {
                    // Still need to escape for HTML display to prevent injection
                    const safeTitle = cardTitle.replace(/[<>&]/g, (char) => {
                        switch (char) {
                            case '<': return '&lt;';
                            case '>': return '&gt;';
                            case '&': return '&amp;';
                            default: return char;
                        }
                    });
                    errorHtml += `<li>${safeTitle}</li>`;
                });
                errorHtml += '</ul>';
                errorDisplay.innerHTML = errorHtml;
                errorDisplay.classList.remove('hidden');
            }

            const xmlResult = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<deck>\n${xmlCards.join('\n')}\n</deck>`;
            xmlOutput.value = xmlResult;
        }

        /**
         * Copies the generated XML to the clipboard.
         */
        function copyToClipboard() {
            if (!xmlOutput.value) {
                showFeedback("Nothing to copy!", "red");
                return;
            }
            try {
                xmlOutput.select();
                xmlOutput.setSelectionRange(0, 99999);
                document.execCommand('copy');
                showFeedback("Copied to clipboard!", "green");
            } catch (err) {
                console.error('Failed to copy text: ', err);
                showFeedback("Failed to copy.", "red");
            }
            if (window.getSelection) {
                window.getSelection().removeAllRanges();
            }
        }

        /**
         * Shows a temporary feedback message to the user.
         * @param {string} message The message to display.
         * @param {string} color The color of the message ('green' or 'red').
         */
        function showFeedback(message, color) {
            const feedbackEl = (message.includes("Copied") || message.includes("Nothing to copy") || message.includes("not loaded")) ? copyFeedback : statusMessage;
            if (feedbackEl !== copyFeedback) {
                 feedbackEl.textContent = message;
            }
            feedbackEl.textContent = message;
            feedbackEl.className = `mt-4 h-6 transition-opacity opacity-100 ${color === 'green' ? 'text-green-400' : 'text-red-500'}`;
            if (message.includes("Copied") || message.includes("Nothing to copy") || message.includes("not loaded")) {
                setTimeout(() => {
                    feedbackEl.classList.replace('opacity-100', 'opacity-0');
                }, 2000);
            }
        }

        // --- Event Listeners and Initial Load ---
        convertBtn.addEventListener('click', convertToXml);
        copyBtn.addEventListener('click', copyToClipboard);
        document.addEventListener('DOMContentLoaded', loadCardData);

    </script>
</body>
</html>
